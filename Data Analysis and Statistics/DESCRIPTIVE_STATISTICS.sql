CREATE PROCEDURE [DBO].[DESCRIPTIVE_STATISTICS]	
 @TABLE_NAME		VARCHAR(MAX)
,@COLUMN_NAMES		VARCHAR(MAX) = '*'	 --Must be sent with commas separating each column
AS

BEGIN TRY

--Developed by oscar_b Nov/2024
/*
--Creating a table for Tests
DROP TABLE IF EXISTS #DESCRIPTIVE_STATISTICS_TEST

SELECT 
	 ABS(CHECKSUM(NEWID())) % 20 COLX
	,ABS(CHECKSUM(NEWID())) % 20 COLY
	,ABS(CHECKSUM(NEWID())) % 20 COLW
	,ABS(CHECKSUM(NEWID())) % 20 COLZ
	INTO #DESCRIPTIVE_STATISTICS_TEST
	FROM STRING_SPLIT(REPLICATE(';', 19), ';')


--Example of Procedure Execution:
EXEC [DBO].[DESCRIPTIVE_STATISTICS]	
	 @TABLE_NAME		= '#DESCRIPTIVE_STATISTICS_TEST'
	,@COLUMN_NAMES		= NULL

EXEC [DBO].[DESCRIPTIVE_STATISTICS]	
	 @TABLE_NAME		= '#DESCRIPTIVE_STATISTICS_TEST'
	,@COLUMN_NAMES		= 'COLX, COLY'
*/

--==============================================
--Part 1: Set variables and tables
--==============================================	
SET @COLUMN_NAMES = REPLACE(COALESCE(@COLUMN_NAMES, '*'), 'ALL', '*')

		--New Variables
DECLARE	 @QUERY				NVARCHAR(MAX)
		,@TMP_TABLE1		NVARCHAR(MAX)
		,@COL_NAME_LOOP		NVARCHAR(MAX)
		,@COL_TYPE_LOOP		NVARCHAR(MAX)
		,@COL_ID_LOOP		INT
		,@AUX_MODE_PT1		INT
		,@AUX_MODE_PT2		INT
		,@AUX_COLUMNS_PIVOT	NVARCHAR(MAX)
		,@ERROR_MESSAGE		NVARCHAR(MAX)


--Create a table used in the execution (It has a dynamic_name)
SET @TMP_TABLE1 = CONCAT('DBO.[TMP_DESCRIPTIVE_STATISTICS_', NEWID(), ']')
--SET @TMP_TABLE1 = CONCAT('DBO.[TMP_DESCRIPTIVE_STATISTICS', ']')

--Drop table
SET @QUERY = 'DROP TABLE IF EXISTS [#TMP_TABLE1]'
SET @QUERY = REPLACE(@QUERY, '[#TMP_TABLE1]'	, @TMP_TABLE1)
EXEC(@QUERY)

--Create Table Used
SET @QUERY = 
'SELECT *
INTO [#TMP_TABLE1]
FROM
(SELECT
	[#COLUMN_NAMES]
	FROM [#TABLE_NAME] Z) A '

SET @QUERY = REPLACE(@QUERY, '[#TMP_TABLE1]'	, @TMP_TABLE1)
SET @QUERY = REPLACE(@QUERY, '[#COLUMN_NAMES]'	, @COLUMN_NAMES)
SET @QUERY = REPLACE(@QUERY, '[#TABLE_NAME]'	, @TABLE_NAME)
EXEC(@QUERY)

--Tables used in the loop
DROP TABLE IF EXISTS #DESCRIPTIVE_STATISTICS_LOOP_CURSOR
DROP TABLE IF EXISTS #DESCRIPTIVE_STATISTICS_LOOP
DROP TABLE IF EXISTS #DESCRIPTIVE_STATISTICS 


--Table that works like a cursor
DECLARE @DESCRIPTIVE_STATISTICS_LOOP_CURSOR TABLE (
	 COLUMN_ID				INT
	,COLUMN_NAME			NVARCHAR(MAX)
	,COLUMN_TYPE			NVARCHAR(MAX)
	,FLAG_LOOP_CURSOR		BIT
)

--Table of the loop
CREATE TABLE #DESCRIPTIVE_STATISTICS_LOOP (
	 COLUMN_NAME			NVARCHAR(MAX)
	,COLUMN_VALUE			NVARCHAR(MAX)
	,COLUMN_VALUE_NUMERIC	FLOAT
)

--Final Table
CREATE TABLE #DESCRIPTIVE_STATISTICS (
	 ID_SEQ				INT IDENTITY
	,NUM_ORDER			INT
	,COLUMN_NAME		NVARCHAR(MAX)
	,METRIC_NAME		NVARCHAR(MAX)
	,METRIC_VALUE		NVARCHAR(MAX)
)


--==============================================
--Part 2: Go Through all the columns
--==============================================

--Insert data in the table that works like a Cursor
INSERT INTO @DESCRIPTIVE_STATISTICS_LOOP_CURSOR
(COLUMN_ID, COLUMN_NAME, COLUMN_TYPE, FLAG_LOOP_CURSOR)
SELECT 
	 A.COLUMN_ID				AS COLUMN_ID
	,A.NAME						AS COLUMN_NAME
	,B.NAME						AS COLUMN_TYPE
	,0							AS FLAG_LOOP_CURSOR
	FROM SYS.COLUMNS A
	INNER JOIN SYS.TYPES B ON A.SYSTEM_TYPE_ID = B.SYSTEM_TYPE_ID
	WHERE OBJECT_ID = OBJECT_ID(@TMP_TABLE1)
	ORDER BY A.COLUMN_ID


--Going each row of the cursor
WHILE EXISTS
	(SELECT 1
		FROM @DESCRIPTIVE_STATISTICS_LOOP_CURSOR
		WHERE FLAG_LOOP_CURSOR = 0
	)
BEGIN

SELECT TOP 1
	 @COL_ID_LOOP	= COLUMN_ID
	,@COL_NAME_LOOP	= COLUMN_NAME
	,@COL_TYPE_LOOP = COLUMN_TYPE
	FROM @DESCRIPTIVE_STATISTICS_LOOP_CURSOR
	WHERE FLAG_LOOP_CURSOR = 0
	ORDER BY COLUMN_ID

TRUNCATE TABLE #DESCRIPTIVE_STATISTICS_LOOP

--Create table of the Loop (data of each column)
SET @QUERY = 
'
INSERT INTO #DESCRIPTIVE_STATISTICS_LOOP
(COLUMN_NAME, COLUMN_VALUE, COLUMN_VALUE_NUMERIC)
SELECT
	''[#COL_NAME_LOOP]''		AS COLUMN_NAME
	,[#COL_NAME_LOOP]			AS COLUMN_VALUE
	,CONVERT(FLOAT, NULL)		AS COLUMN_VALUE_NUMERIC
	FROM [#TMP_TABLE1]
'
SET @QUERY = REPLACE(@QUERY, '[#COL_NAME_LOOP]'	, @COL_NAME_LOOP)
SET @QUERY = REPLACE(@QUERY, '[#TMP_TABLE1]'	, @TMP_TABLE1)
EXEC(@QUERY)

--Update Value co Numeric Column
UPDATE #DESCRIPTIVE_STATISTICS_LOOP
	SET COLUMN_VALUE_NUMERIC = TRY_CONVERT(FLOAT, CONVERT(NVARCHAR(MAX), COLUMN_VALUE))
	WHERE @COL_TYPE_LOOP NOT IN
	('text','ntext','varchar','char','nvarchar','nchar','sysname')

--=========================
--Part 2.1: Populate the final table - Text Columns
--=========================

--Insert Metric: Null Values
INSERT INTO #DESCRIPTIVE_STATISTICS
(NUM_ORDER, COLUMN_NAME, METRIC_NAME, METRIC_VALUE)
SELECT DISTINCT
	 3														AS NUM_ORDER
	,COLUMN_NAME
	,'Count - Null'											AS METRIC_NAME
	,SUM(CASE WHEN COLUMN_VALUE IS NULL THEN 1 ELSE 0 END)	AS METRIC_VALUE
	FROM #DESCRIPTIVE_STATISTICS_LOOP
	GROUP BY COLUMN_NAME

--Delete Null Values
DELETE FROM #DESCRIPTIVE_STATISTICS_LOOP WHERE COLUMN_VALUE IS NULL

--Insert Metric: Count, Unique
INSERT INTO #DESCRIPTIVE_STATISTICS
(NUM_ORDER, COLUMN_NAME, METRIC_NAME, METRIC_VALUE)
SELECT DISTINCT
	 1								AS NUM_ORDER
	,COLUMN_NAME
	,'Count'						AS METRIC_NAME
	,COUNT(COLUMN_VALUE)			AS METRIC_VALUE
	FROM #DESCRIPTIVE_STATISTICS_LOOP
	GROUP BY COLUMN_NAME
UNION ALL
SELECT DISTINCT
	 2								AS NUM_ORDER
	,COLUMN_NAME
	,'Count - Unique'				AS METRIC_NAME
	,COUNT(DISTINCT COLUMN_VALUE)	AS METRIC_VALUE
	FROM #DESCRIPTIVE_STATISTICS_LOOP
	GROUP BY COLUMN_NAME

--Insert Metric: Mode - Value (
SELECT TOP 1
	@AUX_MODE_PT1 = COUNT(1)
	FROM #DESCRIPTIVE_STATISTICS_LOOP
	GROUP BY COLUMN_VALUE
	ORDER BY 1 DESC

INSERT INTO #DESCRIPTIVE_STATISTICS
(NUM_ORDER, COLUMN_NAME, METRIC_NAME, METRIC_VALUE)
SELECT
	 4									AS NUM_ORDER
	,@COL_NAME_LOOP						AS COLUMN_NAME
	,'Mode - Values'					AS METRIC_NAME
	,STRING_AGG(COLUMN_VALUE, ' | ')	AS METRIC_VALUE
	FROM (
SELECT TOP 4
	COLUMN_VALUE, COUNT(1)	AS COUNT_VALUES
	FROM #DESCRIPTIVE_STATISTICS_LOOP
	GROUP BY COLUMN_VALUE
	HAVING COUNT(1) = @AUX_MODE_PT1
) A

--Insert Metric: Mode - Quantity
INSERT INTO #DESCRIPTIVE_STATISTICS
(NUM_ORDER, COLUMN_NAME, METRIC_NAME, METRIC_VALUE)
SELECT DISTINCT 
	 5								AS NUM_ORDER
	,@COL_NAME_LOOP
	,'Mode - Quantity'				AS METRIC_NAME
	,@AUX_MODE_PT1					AS METRIC_VALUE


--=========================
--Part 2.2: Populate the final table - Numeric Columns
--=========================
IF EXISTS
	(SELECT 1
		FROM #DESCRIPTIVE_STATISTICS_LOOP
		WHERE COLUMN_VALUE_NUMERIC IS NOT NULL
	 )
BEGIN

--Insert Metric: Mean, Standard Deviation, Min, 25%, 50%, 75%, Max
INSERT INTO #DESCRIPTIVE_STATISTICS
(NUM_ORDER, COLUMN_NAME, METRIC_NAME, METRIC_VALUE)	
SELECT DISTINCT
	 6										AS NUM_ORDER
	,@COL_NAME_LOOP							AS COLUMN_NAME
	,'Mean'									AS METRIC_NAME
	,AVG(COLUMN_VALUE_NUMERIC * 1.0)		AS METRIC_VALUE
	FROM #DESCRIPTIVE_STATISTICS_LOOP
UNION ALL
SELECT DISTINCT
	 7								AS NUM_ORDER
	,@COL_NAME_LOOP					AS COLUMN_NAME
	,'Std'							AS METRIC_NAME
	,STDEV(COLUMN_VALUE_NUMERIC)	AS METRIC_VALUE
	FROM #DESCRIPTIVE_STATISTICS_LOOP
UNION ALL
SELECT DISTINCT
	 8								AS NUM_ORDER
	,@COL_NAME_LOOP					AS COLUMN_NAME
	,'Min'							AS METRIC_NAME
	,MIN(COLUMN_VALUE_NUMERIC)		AS METRIC_VALUE
	FROM #DESCRIPTIVE_STATISTICS_LOOP
UNION ALL
SELECT DISTINCT
	 9								AS NUM_ORDER
	,@COL_NAME_LOOP					AS COLUMN_NAME
	,'25%'							AS METRIC_NAME
	,PERCENTILE_CONT(0.25) WITHIN GROUP(ORDER BY COLUMN_VALUE_NUMERIC)  OVER ()	AS METRIC_VALUE
	FROM #DESCRIPTIVE_STATISTICS_LOOP
UNION ALL
SELECT DISTINCT
	 10								AS NUM_ORDER
	,@COL_NAME_LOOP					AS COLUMN_NAME
	,'50%'							AS METRIC_NAME
	,PERCENTILE_CONT(0.50) WITHIN GROUP(ORDER BY COLUMN_VALUE_NUMERIC)  OVER ()	AS METRIC_VALUE
	FROM #DESCRIPTIVE_STATISTICS_LOOP
UNION ALL
SELECT DISTINCT
	 11								AS NUM_ORDER
	,@COL_NAME_LOOP					AS COLUMN_NAME
	,'75%'							AS METRIC_NAME
	,PERCENTILE_CONT(0.75) WITHIN GROUP(ORDER BY COLUMN_VALUE_NUMERIC)  OVER ()	AS METRIC_VALUE
	FROM #DESCRIPTIVE_STATISTICS_LOOP
UNION ALL
SELECT DISTINCT
	 12								AS NUM_ORDER
	,@COL_NAME_LOOP					AS COLUMN_NAME
	,'Max'							AS METRIC_NAME
	,MAX(COLUMN_VALUE_NUMERIC)		AS METRIC_VALUE
	FROM #DESCRIPTIVE_STATISTICS_LOOP

END

--Update the Line in the Loop
UPDATE A
	SET A.FLAG_LOOP_CURSOR = 1
	FROM @DESCRIPTIVE_STATISTICS_LOOP_CURSOR A
	WHERE COLUMN_ID = @COL_ID_LOOP

END



--Aditional update for Modes with more than 3 values
UPDATE A
	SET A.METRIC_VALUE =
		--CONCAT(A.METRIC_VALUE, ' | ...')
		REVERSE(STUFF(REVERSE(A.METRIC_VALUE), 1, CHARINDEX('|', REVERSE(A.METRIC_VALUE)), '... |'))
	FROM #DESCRIPTIVE_STATISTICS A
	WHERE METRIC_NAME = 'Mode - Values'
		AND LEN(METRIC_VALUE) - LEN(REPLACE(METRIC_VALUE, '|', '')) >= 3

--==============================================
--Part 3: Final Output
--==============================================

--Set all column for Pivoted Columns
SET @AUX_COLUMNS_PIVOT = 
(SELECT
	CONCAT(',[', A.NAME, ']')
	FROM SYS.COLUMNS A
	WHERE OBJECT_ID = OBJECT_ID(@TMP_TABLE1)
	ORDER BY A.COLUMN_ID
	FOR XML PATH('')
)

SET @AUX_COLUMNS_PIVOT = STUFF(@AUX_COLUMNS_PIVOT, 1, 1, '')


--Create Final Select
SET @QUERY =
'SELECT 
 METRIC_NAME
,[#AUX_COLUMNS_PIVOT]
FROM (
SELECT NUM_ORDER, COLUMN_NAME, METRIC_NAME, METRIC_VALUE
	FROM #DESCRIPTIVE_STATISTICS
) A
PIVOT(MAX(METRIC_VALUE) FOR COLUMN_NAME IN
		([#AUX_COLUMNS_PIVOT])
	  ) PVT
	ORDER BY NUM_ORDER
'
SET @QUERY = REPLACE(@QUERY, '[#AUX_COLUMNS_PIVOT]'	, @AUX_COLUMNS_PIVOT)
EXEC(@QUERY)


--Drop tables used in the process
SET @QUERY = 'DROP TABLE IF EXISTS [#TMP_TABLE1]'
SET @QUERY = REPLACE(@QUERY, '[#TMP_TABLE1]'	, @TMP_TABLE1)
EXEC(@QUERY)

	
END TRY

--If there's any error during the the execution
BEGIN CATCH

--Drop the table created in case of error
SET @QUERY = 'DROP TABLE IF EXISTS [#TMP_TABLE1]'
SET @QUERY = REPLACE(@QUERY, '[#TMP_TABLE1]'	, @TMP_TABLE1)
EXEC(@QUERY)

--Inform the Error	
SET @ERROR_MESSAGE = CONCAT('Error ', ERROR_NUMBER(), ' - ', ERROR_MESSAGE())
RAISERROR(@ERROR_MESSAGE, 11,1)

END CATCH
